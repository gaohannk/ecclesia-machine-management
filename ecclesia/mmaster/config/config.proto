// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package ecclesia;

// Top-level machine master configuration (MMC). The machine master requires one
// of these configs to specify what frontends it should export and what backends
// it will communicate with.
message MachineMasterConfiguration {
  // Defines how the various machine master frontends should be configured.
  FrontendConfig frontend = 1;
  // Defines the set of management agents to use as data sources and how to
  // communicate with them.
  repeated AgentConfig agent = 2;
  // Defines how to merge telemetry from all of the individual agents into a
  // single unified machine abstraction.
  PluginGraphMergeSpec merge_spec = 3;
  // Specifies the OS domain of the OS that the machine master (and this config)
  // are running in. May be empty if the master is non-local.
  string local_os_domain = 4;
}

// Various configuration messages for identifying sockets.
message SocketConfig {
  message UnixDomain {
    string path = 1;
  }
  message NetworkPort {
    int32 port = 1;
    string hostname = 2;
  }
}

message FrontendConfig {
  // Provide an emulated gsys implementation. This will export a partial
  // implementation of the gsys RPC and streamz interfaces.
  message Gsys {
    SocketConfig.UnixDomain unix_domain = 1;
    SocketConfig.UnixDomain stubby_domain = 6;
    SocketConfig.NetworkPort loopback = 2;
    SocketConfig.NetworkPort network = 3;

    // Users granted root-equivalent permissions.
    //
    // WARNING: Users in this list will be able to call ANY gsys RPC.
    repeated string root_grant = 4;

    // RPC specific grants.
    message RpcGrant {
      string user = 1;
      string rpc = 2;
    }
    repeated RpcGrant rpc_grant = 5;

    // Override the platform taxonomy reported from this backend.
    message PlatformTaxonomy {
      // String representation of the taxonomy broken into parts.
      // E.g. ['indus', 'cascadelake', 'base].
      repeated string taxon = 1;
      // Integer value of the taxonomy bitmask as returned by platforminfo.
      uint32 taxonomy_value = 2;
    }
    // Hardware config assumptions that the Machine Master must report in order
    // for external clients to bootstrap the hardware to be monitored by the
    // Machine Master.
    PlatformTaxonomy taxonomy = 7;
  }
  Gsys gsys = 1;

  // Provide a implementation of the gRPC MachineMaster interface.
  message Grpc {
    SocketConfig.UnixDomain unix_domain = 1;
    SocketConfig.NetworkPort network = 2;
  }
  Grpc grpc = 2;
}

message AgentConfig {
  // Name of the agent. This is how other messages in the configuration will
  // refer to this agent and so it must be unique within an MMC.
  string name = 1;
  // Name of the operating system domain to be attached to any identifiers from
  // the agent which are OS-dependent. This may not be set if the agent does not
  // provide an OS-dependent telemetry at all. If it is set, it may not be
  // unique as there may be multiple agents monitoring different hardware in the
  // context of the same OS.
  string os_domain = 2;

  // The communication channel used to talk to the agent. This defines both the
  // address and the protocol.
  oneof communication_channel {
    SocketConfig.UnixDomain gsys = 3;
    SocketConfig.NetworkPort redfish = 4;
  }

  // In the case where the agent is not reachable, provide a default set of
  // agent local devpaths, so that we can generate consistent devpaths in the
  // event of an agent being unreachable.
  repeated string fallback_plugin = 5;
}

message PluginGraphMergeSpec {
  // Defines which agent is acting as the root of the plugin model.
  string root = 1;

  // Identifies any plugins which appear in two agents.
  //
  // The plugin indicated in appendant devpath is the same as the plugin
  // indicated in the base devpath.
  message SameNode {
    string base_devpath = 1;
    string appendant_devpath = 2;
  }

  // Identifies plugin from one agent which is plugged into a node on another.
  //
  // The plugin indicated in appendant devpath plugs into the plugin indicated
  // in the base devpath.
  message PluggedInNode {
    string base_devpath = 1;
    string appendant_devpath = 2;
    string connector = 3;
  }

  // For a combination of two agents, this message identifies how we can merge
  // the node information.
  message MergeOperation {
    string base_agent = 1;
    string appendant_agent = 2;
    oneof merge {
      SameNode same_node = 3;
      PluggedInNode plugged_in_node = 4;
    }
  }
  repeated MergeOperation merge_ops = 2;

  // For each agent, this message identifies if we need to invert the graph.
  // For more info on how to specify this refer to the associated README.md file
  message InvertOperation {
    string agent = 1;
    string new_root_devpath = 2;
    repeated string upstream_connectors = 3;
  }
  repeated InvertOperation invert_ops = 3;
}
