// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The Ecclesia Machine Master service definition
//
// For a general description of how the Machine Master service interface is
// structured around resources and verbs for those resources, see the
// documentation at go/ecclesia-rpc-api.

syntax = "proto3";

package ecclesia;

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

//
// Messages for general Get* RPCs.
//

message GetProcessInfoResponse {
  // The version number of the machine master service binary.
  string version = 1;
}

//
// Messages for OsDomain resource RPCs.
//

message OsDomainIdentifier {
  // OsDomain name as declared in the machine master config.
  string name = 1;
}

// A generic reusable message type for pairing an OS domain with an OS domain
// specific identifier. These are generally kernel names, but this can be used
// for an kind of ID that's globally unique in the context of a specific OS.
message OsDomainSpecificIdentifier {
  OsDomainIdentifier os_domain = 1;
  string identifier = 2;
}

message EnumerateOsDomainResponse {
  OsDomainIdentifier id = 1;
}

message QueryOsDomainRequest {
  OsDomainIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message QueryOsDomainResponse {
  OsDomainIdentifier id = 1;

  google.rpc.Status status = 2;

  // Boot number for this OS domain.
  uint32 boot_number = 3;
}

//
// Messages for Firmware resource RPCs.
//

message FirmwareIdentifier {
  // Devpath of the component whose firmware is being reported
  string devpath = 1;
}

message EnumerateFirmwareResponse {
  FirmwareIdentifier id = 1;
}

message QueryFirmwareRequest {
  FirmwareIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message QueryFirmwareResponse {
  FirmwareIdentifier id = 1;

  google.rpc.Status status = 2;

  // The "model" describes the specific model of hardware. In general two
  // components should have the same model if they can run the same firmware,
  // and different models if they cannot run the same firmware.
  string model = 3;

  // Firmware version, as reported by the device. There is no standard format
  // that you can assume version will follow.
  string version = 4;

  // Date or timestamp of the firmware build. Format is model specific, and may
  // not be defined.
  string build_date = 5;

  // This flag indicates if this firmware package is updateable via the machine
  // master.
  bool updateable = 6;
}

//
// Messages for Storage resource RPCs.
//

message StorageIdentifier {
  // Devpath of the physical storage device
  string devpath = 1;
}

message EnumerateStorageResponse {
  StorageIdentifier id = 1;

  // Kernel name for the device, if available.
  // Example: The device name found under /dev (sda, nvme0, etc.)
  OsDomainSpecificIdentifier kernel_dev_name = 2;

  // Universal name given to the storage device. (go/universal-names)
  string universal_name = 3;
}

message QueryStorageRequest {
  StorageIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message StorageController {
  // Protocol used to communicate with the storage controller from the server.
  enum Protocol {
    PROTOCOL_UNKNOWN = 0;
    PROTOCOL_SCSI = 1;  // Includes ATA devices as well.
    PROTOCOL_PCIE = 2;
    PROTOCOL_NVME = 3;
  }
  Protocol storage_protocol = 1;
  string firmware_version = 2;
  // PCIe address as a string (lowercase hex) (e.g. "0000:8e:00.0")
  string pcie_address = 3;
}

// Represents a logical drive, partition or LUN
message StorageVolume {
  // The kernel name given to the logical drive
  // Example: nvme0n1, nvme0n2
  string os_device_name = 1;
  // Capacity in Bytes
  uint64 capacity = 2;
}

message QueryStorageResponse {
  StorageIdentifier id = 1;
  google.rpc.Status status = 2;

  // (Google persistent name) Look like hd[a-z]+, are assigned to a drive by the
  // tunedisknames utility, and stored in the drive's MBR.
  string persistent_name = 3;

  // Defines the underlying type of storage media. Note that this does not
  // necessarily imply a particular type of protocol or device; for example an
  // incredibly wide variety of storage devices use solid state storage.
  enum MediaType {
    MEDIA_TYPE_UNKNOWN = 0;
    MEDIA_TYPE_HDD = 1;  // Electro-mechanical devices using magnetic storage.
    MEDIA_TYPE_SSD = 2;
  }
  MediaType media_type = 4;
  // This is the total amount of addressable capacity as exported by the
  // firmware on the storage device. You can also view this as how much data can
  // be stored on the storage device in the absence of any data reduction.
  uint64 usable_capacity = 5;
  // Block size i.e. the smallest addressable unit in which read/write accesses
  // can be made, in bytes.
  uint32 block_size = 6;
  // Basic identifying information about the storage device.
  string part_number = 7;
  string serial_number = 8;
  string manufacturer = 9;
  // Information about the controller on the storage device.
  StorageController storage_controller = 10;
  // Information about all of the volumes on the device.
  repeated StorageVolume volumes = 11;
}

//
// Messages for Assembly resource RPCs.
//

// Assembly resource represents a single field replaceable unit
message AssemblyIdentifier {
  string devpath = 1;
}

message EnumerateAssemblyResponse {
  AssemblyIdentifier id = 1;
}

message QueryAssemblyRequest {
  AssemblyIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message QueryAssemblyResponse {
  AssemblyIdentifier id = 1;
  google.rpc.Status status = 2;
  string name = 3;
  string part_number = 4;
  string serial_number = 5;
}

//
// Messages for Sensor resource RPCs.
//

message SensorIdentifier {
  // If we add new SensorIdentifiers, we need to make sure that the
  // platforms_gsys mapping is updated as needed. It's possible that new sensor
  // types may be added here which will not be supported by Gsys, in which case
  // no change may be required.
  // LINT.IfChange
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_THERMAL_DEGREES = 1;
    TYPE_THERMAL_MARGIN_DEGREES = 2;
    TYPE_VOLTAGE_VOLTS = 3;
    TYPE_FANTACH_RPM = 4;
    TYPE_CURRENT_AMPS = 5;
    TYPE_POWER_WATTS = 6;
    TYPE_FREQUENCY_HERTZ = 7;
    TYPE_DUTYCYCLE_PERCENT = 8;
    TYPE_ENERGY_JOULES = 9;
    TYPE_OEM_STATE = 10;
    TYPE_TIME_SECONDS = 11;
  }
  // LINT.ThenChange(
  // //depot/google3/platforms/ecclesia/mmaster/middles/collector/gsys.cc)

  string devpath = 1;
  string name = 2;
  Type type = 3;
}

message EnumerateSensorResponse {
  SensorIdentifier id = 1;
}

message QuerySensorRequest {
  SensorIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message QuerySensorResponse {
  SensorIdentifier id = 1;
  google.rpc.Status status = 2;
  double reading = 3;
  google.protobuf.Timestamp timestamp = 4;
}

//
// Messages for PowerDomain resource RPCs.
//

message PowerDomainIdentifier {
  string controller_devpath = 1;
}

message EnumeratePowerDomainResponse {
  PowerDomainIdentifier id = 1;
}

message QueryPowerDomainRequest {
  PowerDomainIdentifier id = 1;
  google.protobuf.FieldMask field_mask = 2;
}

message QueryPowerDomainResponse {
  PowerDomainIdentifier id = 1;
  google.rpc.Status status = 2;
  // The devpaths of the hardware components contained in this power domain.
  repeated string contained_devpaths = 3;
  // The OS domains contained in this power domain.
  repeated OsDomainIdentifier contained_os_domains = 4;
}

message MutatePowerDomainResetRequest {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    // Reset for the hardware but not power cycle. The power based soft straps
    // (mostly) are left intact and hardware will reset to default state.
    // Software has to reinitialize hardware.
    TYPE_NO_CYCLE = 1;
    // Except for standby power, all other rails will be power cycled.
    TYPE_POWER_BUTTON = 2;
    // Except for battery backed power rails, everything will be power cycled.
    TYPE_POWER_CYCLE = 3;
  }
  PowerDomainIdentifier id = 1;
  Type type = 2;
  google.protobuf.Duration reset_delay = 3;
}

message MutatePowerDomainResetResponse {}

//
// The service definition.
//

service MachineMasterService {
  // Enumerate RPC for OsDomain resource
  rpc EnumerateOsDomain(google.protobuf.Empty)
      returns (stream EnumerateOsDomainResponse);
  // Query RPC for OsDomain resource
  rpc QueryOsDomain(stream QueryOsDomainRequest)
      returns (stream QueryOsDomainResponse);

  // Enumerate RPC for Firmware resource
  rpc EnumerateFirmware(google.protobuf.Empty)
      returns (stream EnumerateFirmwareResponse);
  // Query RPC for Firmware resource
  rpc QueryFirmware(stream QueryFirmwareRequest)
      returns (stream QueryFirmwareResponse);

  // Enumerate RPC for Storage resource
  rpc EnumerateStorage(google.protobuf.Empty)
      returns (stream EnumerateStorageResponse);
  // Query RPC for Storage resource
  rpc QueryStorage(stream QueryStorageRequest)
      returns (stream QueryStorageResponse);

  // Enumerate RPC for Assembly resource
  rpc EnumerateAssembly(google.protobuf.Empty)
      returns (stream EnumerateAssemblyResponse);
  // Query RPC for Assembly resource
  rpc QueryAssembly(stream QueryAssemblyRequest)
      returns (stream QueryAssemblyResponse);

  // Enumerate RPC for Sensor resource
  rpc EnumerateSensor(google.protobuf.Empty)
      returns (stream EnumerateSensorResponse);
  // Query RPC for Sensor resource
  rpc QuerySensor(stream QuerySensorRequest)
      returns (stream QuerySensorResponse);

  // Enumerate RPC for PowerDomain resource
  rpc EnumeratePowerDomain(google.protobuf.Empty)
      returns (stream EnumeratePowerDomainResponse);
  // Query RPC for PowerDomain resource
  rpc QueryPowerDomain(stream QueryPowerDomainRequest)
      returns (stream QueryPowerDomainResponse);
  // MutatePowerDomainReset performs the specified reset after a specified
  // delay if the RPC returns success. Note that the RPC returns success
  // indicating that it has accepted the reset command, NOT when the power
  // domain actually performs the reset after the delay.
  rpc MutatePowerDomainReset(MutatePowerDomainResetRequest)
      returns (MutatePowerDomainResetResponse);
}
